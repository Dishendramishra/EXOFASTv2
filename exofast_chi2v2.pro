;+
; NAME:
;   EXOFAST_CHI2
;
; PURPOSE: 
;   Computes the chi2 for a transit and/or RV for a single planet
;
; CALLING SEQUENCE:
;    chi2 = exofast_chi2v2(pars)
;
; INPUTS:
;
;    PARS - An array of parameters that describes the model. There
;           should be one for each parameter in the structure where
;           fit==true. This array should be generated by str2pars.pro.
;
; OPTIONAL INPUTS:
; 
;    PSNAME      - If specified, this routine will generate
;                  postscript figure for each model generated with a
;                  base of PSNAME. 
;
; OPTIONAL OUTPUTS:
;    
;    DETERMINANT - The determinant of the Jacobian to weight the
;                  acceptance likelihood in order to impose
;                  non-uniform priors in the stepping parameters. This
;                  is equal to 1 (no transformation) unless MIST
;                  models are used. If MIST models are used,
;                  DETERMINANT is equal to d(EEP)/d(Age) to transform
;                  the uniform EEP prior into a uniform Age prior.
;    MODELRV     - The RV model given the parameters
;    MODELFLUX   - The Transit model given the parameters
;    DERIVED     - An array of derived parameters. Nothing is ever
;                  returned in DERIVED, but this keyword is required
;                  by EXOFAST_DEMC.
;
; RESULT:
;    The chi^2 of the model given the data and parameters.
;
; COMMON BLOCKS:
;   CHI2_BLOCK - See exofastv2.pro for definition
;
; MODIFICATION HISTORY
; 
;  2018/03 -- Create documentation -- Jason Eastman (CfA)
;-

function exofast_chi2v2, pars, determinant=determinant, $
                         modelrv=modelrv, modelflux=modelflux, psname=psname, $
                         derived=derived

COMMON chi2_block, ss
;; populate the structure with the new parameters
if n_elements(pars) ne 0 then pars2str, pars, ss

au = ss.constants.au/ss.constants.rsun

;; derive all required parameters 
;; (this may change depending on parameterization)
;derivepars, ss

;; initialize the determinant and chi^2
chi2 = 0.d0
determinant = 1d0

;; physical limb darkening
if (where(ss.planet.fittran))[0] ne -1 then begin
   bad = where(ss.band.u1.value + ss.band.u2.value gt 1d0 or $
               ss.band.u1.value + ss.band.u2.value lt 0d0 or $
               ss.band.u2.value lt -1 or ss.band.u2.value gt 1d0, nbad)
   
   if nbad gt 0 then begin
      if ss.debug then printandlog, strtrim(nbad,2) + ' limb darkening parameters are bad (' + strtrim(ss.band[bad[0]].u1.value,2) + ', ' + strtrim(ss.band[bad[0]].u2.value,2) + ')',ss.logname
      return, !values.d_infinity
   endif
endif

;; prevent runaways
bad = where(ss.planet.logp.value gt 7d0 or ss.planet.logp.value lt -1d0,nbad)
;bad = where(ss.planet.logp.value gt 3d0 or ss.planet.logp.value lt 0d0,nbad)
if nbad gt 0 then begin
   if ss.debug then printandlog, 'logP is bad (' + strtrim(bad,2) + ')', ss.logname
   return, !values.d_infinity
endif

;; prevent runaways
bad = where(ss.planet.tc.value lt ss.planet.tc.prior - 10^ss.planet.logp.value or $
            ss.planet.tc.value gt ss.planet.tc.prior + 10^ss.planet.logp.value,nbad)
if nbad gt 0 then begin
   if ss.debug then printandlog, 'tc is bad (' + strtrim(bad,2) + ')', ss.logname
   return, !values.d_infinity
endif

;; 0 <= cosi <= 1 (or -1 <= cosi <= 1 if i180 keyword set)
bad = where(ss.planet.cosi.value gt 1 or (ss.planet.cosi.value lt 0 and ~ss.planet.i180) or (ss.planet.cosi.value lt -1),nbad)
if nbad gt 0 then begin
   if ss.debug then printandlog, 'cosi is bad (' + strtrim(bad,2) + ')', ss.logname
   return, !values.d_infinity
endif

;; older than the universe (too conservative?)
if ss.star.age.value gt 13.82d0 or ss.star.age.value lt 0d0 then begin
   if ss.debug then printandlog, strtrim(nbad,2) + ' age is bad (' + strtrim(bad,2) + ')',ss.logname
   return, !values.d_infinity
endif

;; positive extinction
if ss.star.av.value lt 0 then begin
   if ss.debug then printandlog, 'extinction is bad (' + strtrim(ss.star.av.value,2) + ')',ss.logname
   return, !values.d_infinity
endif

;; positive distance
if ss.star.distance.value lt 0 then begin
   if ss.debug then printandlog, 'distance is bad (' + strtrim(ss.star.distance.value,2) + ')',ss.logname
   return, !values.d_infinity
endif

;; bound marginally detected planets to limit (infinite) parameter space at low logK
;; conservative lower limit of 0.1 Ceres in 1 year orbit around sun = 1 um/s
;; conservative upper limit corresponds to ~thousand solar masses
bad = where((ss.planet.logk.value lt -6d0 or ss.planet.logk.value gt 6d0) and ss.planet.logk.fit, nbad)
if nbad gt 0 then begin
   if ss.debug then printandlog, 'k is bad (' + strtrim(bad,2) + ')', ss.logname
   return, !values.d_infinity
endif

if ss.star.errscale.value le 0 then begin
   if ss.debug then printandlog, 'error scale is bad', ss.logname
   return, !values.d_infinity
endif

bad = where(ss.doptom.dtscale.value le 0, nbad)
if nbad gt 0 then begin
   if ss.debug then printandlog, 'dtscale is bad (' + strtrim(bad,2) + ')', ss.logname
   return, !values.d_infinity
endif

if ss.star.alpha.value lt -0.3d0 or ss.star.alpha.value gt 0.7d0 then begin
   if ss.debug then printandlog, 'alpha is bad (' + strtrim(ss.star.alpha.value,2) + ')', ss.logname
   return, !values.d_infinity
endif

;; derive the model parameters from the stepping parameters (return if
;; unphysical)
if step2pars(ss,verbose=ss.debug,logname=ss.logname) eq -1 then begin
   if ss.debug then printandlog, 'stellar system is bad', ss.logname
   return, !values.d_infinity
endif

;; if omega is fit, repopulate the parameter array (it keeps it in range)
if (where(ss.planet.omega.fit))[0] ne -1 then pars = str2pars(ss)

;ss.star.mstar.value = 10^ss.star.logmstar.value

;; use the YY tracks to guide the stellar parameters
if ss.yy then begin
   if keyword_set(psname) then epsname = psname+'.yy.eps'
   yychi2 = massradius_yy3(ss.star.mstar.value, ss.star.feh.value, $
                           ss.star.age.value, ss.star.teff.value,$
                           yyrstar=yyrstar, debug=ss.debug, psname=epsname, $
                           sigmab=ss.constants.sigmab/ss.constants.lsun*ss.constants.rsun^2, $
                           gravitysun=ss.constants.gravitysun)
   if ~finite(yychi2) then begin
      if ss.debug then printandlog, 'star not on YY tracks', ss.logname
      return, !values.d_infinity
   endif

   yychi2 += ((ss.star.rstar.value - yyrstar)/(0.03*yyrstar))^2
   chi2 += yychi2
   if ss.verbose then printandlog, 'YY penalty = ' + strtrim(yychi2,2), ss.logname
endif

;; use the MIST tracks to guide the stellar parameters
if ss.mist then begin
   if keyword_set(psname) then epsname = psname+'.mist.eps'

   mistchi2 = massradius_mist(ss.star.eep.value, ss.star.mstar.value, ss.star.initfeh.value, $
                              ss.star.age.value, ss.star.teff.value,$
                              ss.star.rstar.value, ss.star.feh.value, debug=ss.debug, $
                              epsname=epsname, gravitysun=ss.constants.gravitysun, $
                              fitage=ss.star.age.fit, ageweight=ageweight, logname=ss.logname, verbose=ss.verbose)

   chi2 += mistchi2
   if ss.verbose then printandlog, 'MIST penalty = ' + strtrim(mistchi2,2), ss.logname
   if ~finite(chi2) then begin
      if ss.debug then printandlog, 'star not on MIST tracks', ss.logname
      return, !values.d_infinity
   endif
   determinant *= ageweight ;; correct uniform EEP prior to uniform Age prior

endif

;; use the Torres relation to guide the stellar parameters
if ss.torres then begin
   massradius_torres, ss.star.logg.value, ss.star.teff.value, ss.star.feh.value, mstar_prior, rstar_prior
   umstar = 0.027d0;*100d0 ;; why the factor of 100?!
   urstar = 0.014d0;*100d0
   if mstar_prior lt 0.6d0 then printandlog, $
      'WARNING: Torres not applicable (mstar = ' + $
      strtrim(mstar_prior,2) + '); ignore at beginning. Otherwise, ' + $
      'use MIST, YY, or impose a prior on mstar/rstar',ss.logname
   ;; add "prior" penalty
   chi2 += (alog10(ss.star.mstar.value/mstar_prior)/umstar)^2
   chi2 += (alog10(ss.star.rstar.value/rstar_prior)/urstar)^2

   if ss.verbose then $
      printandlog, 'Torres penalty: ' + string((alog10(ss.star.mstar.value/mstar_prior)/umstar)^2, $
                                               (alog10(ss.star.rstar.value/rstar_prior)/urstar)^2,format='(f0.6,x,f0.6)'), ss.logname
endif

;; add prior penalties
priors = *(ss.priors)
for i=0, n_elements(priors[0,*])-1 do begin

   ;; if it's a detrending variable
   if priors[3,i] eq -1 then begin
      value = ss.(priors[0,i])[priors[1,i]].(priors[2,i]).value
      upperbound = ss.(priors[0,i])[priors[1,i]].(priors[2,i]).upperbound
      lowerbound =  ss.(priors[0,i])[priors[1,i]].(priors[2,i]).lowerbound 
      label =  ss.(priors[0,i])[priors[1,i]].(priors[2,i]).label + '_' + strtrim(priors[1,i],2)
      prior =  ss.(priors[0,i])[priors[1,i]].(priors[2,i]).prior
      priorwidth = ss.(priors[0,i])[priors[1,i]].(priors[2,i]).priorwidth
   endif else begin
      ;; otherwise
      value = (*(ss.(priors[0,i])[priors[1,i]].(priors[2,i]))).(priors[3,i])[priors[4,i]].value
      upperbound = (*(ss.(priors[0,i])[priors[1,i]].(priors[2,i]))).(priors[3,i])[priors[4,i]].upperbound
      lowerbound = (*(ss.(priors[0,i])[priors[1,i]].(priors[2,i]))).(priors[3,i])[priors[4,i]].lowerbound 
      label =  (*(ss.(priors[0,i])[priors[1,i]].(priors[2,i]))).(priors[3,i])[priors[4,i]].label + '_' + strtrim(priors[1,i],2)
      prior = (*(ss.(priors[0,i])[priors[1,i]].(priors[2,i]))).(priors[3,i])[priors[4,i]].prior
      priorwidth = (*(ss.(priors[0,i])[priors[1,i]].(priors[2,i]))).(priors[3,i])[priors[4,i]].priorwidth
   endelse 

   ;; apply the bounds
   if value gt upperbound or value lt lowerbound then begin
      if ss.debug then $
         printandlog, label + '( ' + strtrim(value,2) + ') is out of bounds (' +$
                      strtrim(lowerbound,2) + ',' + strtrim(upperbound,2) + ')',ss.logname
      return, !values.d_infinity
   endif

   ;; apply the Gaussian prior
   chi2 += ((value - prior)/priorwidth)^2

   ;; output debugging info if requested
   if ss.verbose then begin
      str = string(label,((value - prior)/priorwidth)^2, format='(a," penalty = ",f0.6)')
      printandlog, str, logname
   endif

endfor

;; Apply the Mass-Radius relation 
;; Chen & Kipping, 2017 (http://adsabs.harvard.edu/abs/2017ApJ...834...17C)
;; this introduces a near perfect correlation between K and p, which
;; AMOEBA finds challenging to work with (but is handled naturally by DEMC)
;; does it? Or was that a bug that has been fixed?
for j=0, ss.nplanets-1 do begin
   if ss.planet[j].chen then begin

      ;; negative radii are allowed to assess the significance of the
      ;; transit depth. That breaks these relations, so exclude them here
      if ss.planet[j].rpearth.value le 0d0 then begin
         if ss.debug then printandlog, 'rpearth is bad', ss.logname
         return, !values.d_infinity
      endif

      rp = massradius_chen(ss.planet[j].mpearth.value,rperr=rperr)

      ;; add a chi2 penalty for deviation from the mass-radius relation
      ;; if the radius is well-constrained (by transit depth), it
      ;; becomes an implicit constraint on mass. If the mass is well
      ;; constrained (by RV), it is an explicit constraint on
      ;; radius
      chi2 += ((rp - ss.planet[j].rpearth.value)/rperr)^2
      
      if ss.verbose then printandlog, 'chen penalty = ' + strtrim(((rp - ss.planet[j].rpearth.value)/rperr)^2,2),logname
   endif
endfor

;; fit the SED
if file_test(ss.star.fluxfile) then begin
   if keyword_set(psname) then epsname = psname+'.sed.eps'
   sedchi2 = exofast_sed(ss.star.fluxfile, ss.star.teff.value, $
                         ss.star.rstar.value,$
                         ss.star.av.value, ss.star.distance.value, $
                         logg=ss.star.logg.value,met=ss.star.feh.value,$
                         alpha=ss.star.alpha.value,verbose=ss.verbose, $
                         f0=f, fp0=fp, ep0=ep, psname=epsname, $
                         pc=ss.constants.pc, rsun=ss.constants.rsun, $
                         logname=logname, debug=ss.debug)

   if ~finite(sedchi2) then begin
      if ss.debug then printandlog, 'sed is bad', ss.logname
      return, !values.d_infinity
   endif

   sedchi2 = exofast_like(f-fp,0d0,ss.star.errscale.value*ep,/chi2)
   if ~finite(sedchi2) then begin
      if ss.debug then printandlog, 'sed is bad', ss.logname
      return, !values.d_infinity
   endif
   chi2 += sedchi2
   if ss.verbose then printandlog, 'SED penalty = ' + strtrim(sedchi2,2), ss.logname
endif

;; if fitting in v/vcirc & omega, correct for a uniform eccentricity prior
for i=0, ss.nplanets-1 do begin
   if ss.planet[i].vvcirc.fit and ss.planet[i].omega.fit then begin
      jacobian = (-sin(ss.planet[i].omega.value)-ss.planet[i].e.value)/$
                 (sqrt(1d0-ss.planet[i].e.value^2)*(ss.planet[i].e.value*sin(ss.planet[i].omega.value)+1d0)^2)
      determinant *= jacobian
   endif
endfor

;; RV model (non-interacting planets)
for j=0, ss.ntel-1 do begin

   rv = *(ss.telescope[j].rvptrs)

   if (where(rv.err^2 + ss.telescope[j].jittervar.value le 0d0))[0] ne -1 then return, !values.d_infinity

   modelrv = dblarr(n_elements(rv.rv))
   for i=0, ss.nplanets-1 do begin

      if ss.planet[i].fitrv then begin      
         ;; rvbjd = rv.bjd ;; usually sufficient (See Eastman et al., 2013)

         ;; time in target barycentric frame (expensive)
         rvbjd = bjd2target(rv.bjd, inclination=ss.planet[i].i.value, $
                            a=ss.planet[i].a.value, tp=ss.planet[i].tp.value, $
                            period=ss.planet[i].period.value, e=ss.planet[i].e.value,$
                            omega=ss.planet[i].omega.value,/primary,$
                            c=ss.constants.c/ss.constants.au*ss.constants.day)
         
         ;; calculate the RV model
         if ss.planet[i].rossiter then $
            u1 = linld(ss.star.logg.value,ss.star.teff.value,ss.star.feh.value,'V') $
         else u1 = 0d0
         modelrv += exofast_rv(rvbjd,ss.planet[i].tp.value,ss.planet[i].period.value,$
                               0d0,ss.planet[i].K.value,$
                               ss.planet[i].e.value,ss.planet[i].omega.value,$
                               slope=0, $
                               rossiter=ss.planet[i].rossiter, i=ss.planet[i].i.value,a=ss.planet[i].ar.value,$
                               p=abs(ss.planet[i].p.value),vsini=ss.star.vsini.value,$
                               lambda=ss.planet[i].lambda.value,$
                               u1=u1,t0=t0,deltarv=deltarv)

      endif

   endfor
   ;; add instrumental offset, slope, and quadratic term
   modelrv += ss.telescope[j].gamma.value + ss.star.slope.value*(rv.bjd-t0) + ss.star.quad.value*(rv.bjd-t0)^2

   (*ss.telescope[j].rvptrs).residuals = rv.rv - modelrv
   
   if keyword_set(psname) then begin
      base = file_dirname(psname) + path_sep() + file_basename(psname,'.model')
      exofast_forprint, rv.bjd, rv.rv - modelrv, rv.err, format='(f0.8,x,f0.6,x,f0.6)', textout=base + '.residuals.telescope_' + strtrim(j,2) + '.txt', /nocomment,/silent
      exofast_forprint, rv.bjd, modelrv, format='(f0.8,x,f0.6)', textout=base + '.model.telescope_' + strtrim(j,2) + '.txt', /nocomment,/silent
   endif

   rvchi2 = exofast_like((*ss.telescope[j].rvptrs).residuals,ss.telescope[j].jittervar.value,rv.err,/chi2)
   if ~finite(rvchi2) then stop
   chi2 += rvchi2
   if ss.verbose then printandlog, ss.telescope[j].label + ' RV penalty = ' + strtrim(rvchi2,2),ss.logname
endfor

;; if at least one RV planet is fit, plot it
if (where(ss.planet.fitrv))[0] ne -1 then begin
   if keyword_set(psname) then begin
      plotrv, ss, psname=psname + '.rv.ps'
   endif else if ss.debug then begin
      plotrv, ss
   endif
endif

;; Doppler Tomography Model
for i=0, ss.ndt-1 do begin
   if keyword_set(psname) then epsname = psname + '.dt_' + strtrim(i,2) + '.eps'
   dtchi2 = dopptom_chi2(*(ss.doptom[i].dtptrs),$
                         ss.planet[(*(ss.doptom[i].dtptrs)).planetndx].tc.value, $
                         ss.planet[(*(ss.doptom[i].dtptrs)).planetndx].period.value, $
                         ss.planet[(*(ss.doptom[i].dtptrs)).planetndx].e.value,$
                         ss.planet[(*(ss.doptom[i].dtptrs)).planetndx].omega.value, $
                         ss.planet[(*(ss.doptom[i].dtptrs)).planetndx].cosi.value, $
                         ss.planet[(*(ss.doptom[i].dtptrs)).planetndx].p.value,$
                         ss.planet[(*(ss.doptom[i].dtptrs)).planetndx].ar.value,$
                         ss.planet[(*(ss.doptom[i].dtptrs)).planetndx].lambda.value, $
                         ss.star.logg.value, ss.star.teff.value, ss.star.feh.value,$
                         ss.star.vsini.value/1d3,ss.star.macturb.value/1d3,$
                         ss.doptom[i].dtscale.value, debug=ss.debug,/like,psname=epsname)

   if ~finite(dtchi2) then return, !values.d_infinity
   chi2 += dtchi2
   if ss.verbose then printandlog, ss.doptom[i].label + ' DT penalty = ' + strtrim(dtchi2,2),ss.logname
endfor

;; Transit model
for j=0, ss.ntran-1 do begin

   transit = *(ss.transit[j].transitptrs)

   if (where(transit.err^2 + ss.transit[j].variance.value le 0d0))[0] ne -1 then return, !values.d_infinity

   band = ss.band[ss.transit[j].bandndx]

   ;; quadratic limb darkening
   if ss.claret then begin
      ldcoeffs = quadld(ss.star.logg.value, ss.star.teff.value, ss.star.feh.value, band.name)
      u1claret = ldcoeffs[0]
      u2claret = ldcoeffs[1]
      u1err = 0.05d0 
      u2err = 0.05d0
      chi2 += ((band.u1.value-u1claret)/u1err)^2
      chi2 += ((band.u2.value-u2claret)/u2err)^2
      if ss.verbose then printandlog, band.label + ' u1 penalty = ' + strtrim(((band.u1.value-u1claret)/u1err)^2,2),ss.logname
      if ss.verbose then printandlog, band.label + ' u2 penalty = ' + strtrim(((band.u2.value-u2claret)/u2err)^2,2),ss.logname
   endif

   ;; Kepler Long candence data; create several model points and average   
   ninterp = ss.transit[j].ninterp
   npoints = n_elements(transit.bjd)
   if ninterp gt 1 then begin
      transitbjd = transit.bjd#(dblarr(ninterp)+1d0) + $
                   ((dindgen(ninterp)/ninterp-(ninterp-1d0)/(2d0*ninterp))/$
                    1440d0*ss.transit[j].exptime)##(dblarr(npoints)+1d0)
      modelflux = dblarr(npoints,ninterp) + 1d0
   endif else begin
      transitbjd = transit.bjd
      modelflux = dblarr(npoints) + 1d0
   endelse

   ;; get the motion of the star due to all planets
   junk = exofast_getb2(transitbjd,inc=ss.planet.i.value,a=ss.planet.ar.value,$
                        tperiastron=ss.planet.tp.value,$
                        period=ss.planet.period.value,$
                        e=ss.planet.e.value,omega=ss.planet.omega.value,$
                        q=ss.star.mstar.value/ss.planet.mpsun.value,$
                        x1=x1,y1=y1,z1=z1)

   for i=0, ss.nplanets-1 do begin
      if ss.planet[i].fittran then begin
         
         modelflux += (exofast_tran(transitbjd, $
                                    ss.planet[i].i.value + ss.transit[j].tiv.value, $
                                    ss.planet[i].ar.value, $
                                    ss.planet[i].tp.value + ss.transit[j].ttv.value, $
                                    ss.planet[i].period.value, $
                                    ss.planet[i].e.value,$
                                    ss.planet[i].omega.value,$
                                    ss.planet[i].p.value + ss.transit[j].tdeltav.value,$
                                    band.u1.value, $
                                    band.u2.value, $
                                    1d0, $
                                    q=ss.star.mstar.value/ss.planet[i].mpsun.value, $
                                    thermal=band.thermal.value, $
                                    reflect=band.reflect.value, $
                                    dilute=band.dilute.value,$
                                    tc=ss.planet[i].tc.value,$
                                    rstar=ss.star.rstar.value/AU,$
                                    x1=x1,y1=y1,z1=z1,au=au,$
                                    c=ss.constants.c/ss.constants.au*ss.constants.day) - 1d0)
      endif

   endfor

   ;; now integrate the model points (before detrending)
   ;; Riemann integration beats trapezoidal and simpsons wins when sampling like above
   if ninterp gt 1 then modelflux = total(modelflux,2)/ninterp

   ;; Trapezoidal integration not as good
   ;;if ninterp gt 1 then modelflux = (total(modelflux,2) - modelflux[*,0]/2d0 - modelflux[*,-1]/2d0)/(ninterp-1d0)

   ;; Simpson integration (about 2x worse than trap because it
   ;; requires sampling at the midpoint, effectively halving our resolution)
   ;if ninterp gt 1 then modelflux = (4d0*total(modelflux,2) - 3d0*modelflux[*,0] - 3d0*modelflux[*,-1])/(4d0*ninterp - 6d0)

   ;; detrending
   modelflux += total(transit.detrendadd*(replicate(1d0,n_elements(transit.bjd))##transit.detrendaddpars.value),1) 
   modelflux *= (ss.transit[j].f0.value + $
                 total(transit.detrendmult*(replicate(1d0,n_elements(transit.bjd))##transit.detrendmultpars.value),1))

   ;; chi^2
   transitchi2 = exofast_like(transit.flux - modelflux,ss.transit[j].variance.value,transit.err,/chi2)

   (*ss.transit[j].transitptrs).residuals = transit.flux - modelflux
   (*ss.transit[j].transitptrs).model = modelflux

   if keyword_set(psname) then begin
      base = file_dirname(psname) + path_sep() + file_basename(psname,'.model')
      exofast_forprint, transit.bjd, transit.flux - modelflux, transit.err, format='(f0.8,x,f0.6,x,f0.6)', textout=base + '.residuals.transit_' + strtrim(j,2) + '.txt', /nocomment,/silent
      exofast_forprint, transit.bjd, modelflux, format='(f0.8,x,f0.6)', textout=base + '.model.transit_' + strtrim(j,2) + '.txt', /nocomment,/silent
   endif

   if ~finite(transitchi2) then stop

   chi2 += transitchi2
   if ss.verbose then printandlog, ss.transit[j].label + ' transit penalty: ' + strtrim(transitchi2,2) + ' ' + strtrim(ss.transit[j].variance.value,2),ss.logname

endfor

;; plot the transit model and data 
;; if a transit is fit for at least one planet
if ((where(ss.planet.fittran))[0] ne -1) then begin
   if keyword_set(psname) then begin
      plottran, ss, psname=psname + '.transit.ps'
   endif else if ss.debug then begin
      plottran, ss
   endif
endif

;; if TTVs are allowed, add a chi2 penalty to the period and t0 from
;; the fit to a linear ephemeris
;; this imposes the constraint of the linear ephemeris while allowing TTVs
junk = where(ss.fittran, nfittran)
if ss.ttvs and nfittran eq 1 then begin
   ;; an nplanets x ntransits array of model transit times
   time = replicate(1,ss.nplanets)#ss.transit.ttv.value + $
          ss.planet.tc.value#replicate(1,ss.ntran) + $
          ss.planet.period.value#replicate(1,ss.ntran)*$
          ss.transit.epoch

   ;; add a chi2 penalty for the deviation of the ephemeris to the
   ;; linear fit of the transit times for each planet
   for i=0L, ss.nplanets-1L do begin

      good = where(finite(time[i,*]),ngood) ;; why wouldn't that be finite??
      if ngood lt 2 then continue
;      if ngood lt 2 then stop ;continue

      coeffs = poly_fit((ss.transit.epoch)[i,good],time[i,good],1, sigma=sigma, yfit=yfit)
      sigma = (sigma > 1d-18)

      chi2 += ((coeffs[0]-ss.planet[i].tc.value)/sigma[0])^2
      chi2 += ((coeffs[1]-ss.planet[i].period.value)/sigma[1])^2

      if ss.verbose then begin
         printandlog, 'Tc penalty ' + strtrim(((coeffs[0]-ss.planet[i].tc.value)/sigma[0])^2,2),ss.logname
         printandlog, 'Period penalty ' + strtrim(((coeffs[1]-ss.planet[i].period.value)/sigma[1])^2,2),ss.logname
      endif

      if ss.debug or keyword_set(psname) then begin
         if keyword_set(psname) then begin
            ;; astrobetter.com tip on making pretty IDL plots
            mydevice=!d.name
            set_plot, 'PS'
            aspect_ratio=1.5
            xsize=10.5
            ysize=xsize/aspect_ratio
            !p.font=0
            device, filename=psname + '.ttv.' + strtrim(i,2) + '.eps', /color, bits=24,/encapsulated
            device, xsize=xsize, ysize=ysize
            LOADCT, 39,/silent
            colors = [0,254,159,95,223,31,207,111,191,47]
            charsizelegend = 0.09
            xlegend = 0.1
            ylegend = 0.90
            charsize = 0.5
         endif else begin
            device,window_state=win_state
            if win_state[10+i] eq 1 then wset, 10+i $
            else window, 10+i, retain=2
            colors= ['ffffff'x,'0000ff'x,'00ff00'x,'ff0000'x,'0080ff'x,$
                     '800080'x,'00ffff'x,'ffff00'x,'80d000'x,'660000'x]
            charsizelegend = 0.03
            xlegend = 0.90
            ylegend = 0.95
            charsize = 1
         endelse
         ncolors = n_elements(colors)
         syms = [0,3,8,5,0,3,8,5]
         fill = [1,1,1,1,0,0,0,0]
         nsyms = n_elements(syms)
         
         telescopes = strarr(ss.ntran)
         for j=0L, ss.ntran-1L do telescopes[j] = (strsplit(ss.transit[j].label,' UT ',/regex,/extract))[0]
         sorted = sort(telescopes)
         tnames = telescopes[sorted[uniq(telescopes[sorted])]]

         xmin = min((ss.transit.epoch)[i,good],max=xmax)
         ymin = min((time[i,good]-yfit)*86400d0,max=ymax)
         plot, [0],[0],psym=3, xtitle='!3Epoch', ytitle='!3O-C (seconds)',xrange=[xmin,xmax],yrange=[ymin,ymax]
         for j=0, n_elements(tnames)-1 do begin
            observed = where(telescopes eq tnames[j])
            if observed[0] ne -1 then begin
               plotsym, syms[j mod nsyms], color=colors[j mod ncolors],fill=fill[j mod nsyms]
               oplot, ((ss.transit.epoch)[i,good])[observed],(time[i,good[observed]]-yfit[observed])*86400d0,psym=8
               xsize = (!x.crange[1] - !x.crange[0])
               ysize = (!y.crange[1] - !y.crange[0])

               ;; only need a legend if we have more than one telescope
               if n_elements(tnames) gt 1 then begin
                  xyouts, !x.crange[0] + xlegend*xsize,!y.crange[0]+(ylegend - j*charsizelegend)*ysize, $
                          tnames[j],color=colors[j mod ncolors],charsize=charsize
                  oplot, [!x.crange[0]+xlegend*xsize-xsize/20],$
                         [!y.crange[0]+(ylegend - (j-0.25)*charsizelegend)*ysize],psym=8
               endif
            endif
         endfor
         oplot, [-9d9,9d9],[0d0,0d0],linestyle=2

         if keyword_set(psname) then begin
            !p.font=-1
            !p.multi=0
            device, /close
            device, encapsulated=0
            set_plot, mydevice
         endif

      endif
   endfor
endif


;   plot, transitbjd, transit.flux, psym=1,/ynoz
;   oplot, transitbjd, modelflux, color=red

;; print all the parameters and the chi^2
if ss.debug then printandlog, string(pars, chi2, format='(' + strtrim(n_elements(pars)+1,2) + '(f0.8,x))'),ss.logname

;printandlog, ss.planet[0].p.value, ss.logname
;wait, 0.1
;stop

;if keyword_set(psname) then begin
;   device, /close
;   set_plot, mydevice
;endif

;; if this stop is triggered, you've found a bug!!
if ~finite(chi2) then stop

return, chi2

end

